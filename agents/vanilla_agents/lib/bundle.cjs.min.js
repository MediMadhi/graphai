"use strict";var e=require("graphai"),a=require("@graphai/agent_utils");const t=async({params:a,namedInputs:t})=>{e.assert(!!t,"stringSplitterAgent: namedInputs is UNDEFINED!");const r=t.text,s=a.chunkSize??2048,n=a.overlap??Math.floor(s/8),p=Math.floor(r.length/(s-n))+1;return{contents:new Array(p).fill(void 0).map(((e,a)=>{const t=a*(s-n);return r.substring(t,t+s)})),count:p,chunkSize:s,overlap:n}},r={name:"stringSplitterAgent",agent:t,mock:t,inputs:{type:"object",properties:{text:{type:"string",description:"text to be chuncked"}},required:["text"]},output:{type:"object",properties:{contents:{type:"array",description:"the array of text chunks"},count:{type:"number",description:"the number of chunks"},chunkSize:{type:"number",description:"the chunk size"},overlap:{type:"number",description:"the overlap size"}}},samples:[{inputs:{text:"Here's to the crazy ones, the misfits, the rebels, the troublemakers, the round pegs in the square holes ... the ones who see things differently -- they're not fond of rules, and they have no respect for the status quo. ... You can quote them, disagree with them, glorify or vilify them, but the only thing you can't do is ignore them because they change things. ... They push the human race forward, and while some may see them as the crazy ones, we see genius, because the people who are crazy enough to think that they can change the world, are the ones who do."},params:{chunkSize:64},result:{contents:["Here's to the crazy ones, the misfits, the rebels, the troublema","roublemakers, the round pegs in the square holes ... the ones wh"," ones who see things differently -- they're not fond of rules, a","rules, and they have no respect for the status quo. ... You can ","You can quote them, disagree with them, glorify or vilify them, ","y them, but the only thing you can't do is ignore them because t","ecause they change things. ... They push the human race forward,","forward, and while some may see them as the crazy ones, we see g","we see genius, because the people who are crazy enough to think ","o think that they can change the world, are the ones who do."," do."],count:11,chunkSize:64,overlap:8}}],description:"This agent strip one long string into chunks using following parameters",category:["string"],author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/string_agents/string_splitter_agent.ts",package:"@graphai/vanilla",license:"MIT"},s=(a,t,r)=>"string"==typeof a?a===t?r:a.replace(t,r):Array.isArray(a)?a.map((e=>s(e,t,r))):e.isObject(a)?Object.keys(a).reduce(((e,n)=>(e[n]=s(a[n],t,r),e)),{}):a,n=async({params:e,namedInputs:a})=>{if(void 0===e.template){if(a.text)return a.text;console.warn("warning: stringTemplateAgent no template")}return Object.keys(a).reduce(((e,t)=>s(e,"${"+t+"}",a[t])),e.template)},p={message1:"hello",message2:"test"},o={name:"stringTemplateAgent",agent:n,mock:n,samples:[{inputs:p,params:{template:"${message1}: ${message2}"},result:"hello: test"},{inputs:p,params:{template:["${message1}: ${message2}","${message2}: ${message1}"]},result:["hello: test","test: hello"]},{inputs:p,params:{template:{apple:"${message1}",lemon:"${message2}"}},result:{apple:"hello",lemon:"test"}},{inputs:p,params:{template:[{apple:"${message1}",lemon:"${message2}"}]},result:[{apple:"hello",lemon:"test"}]},{inputs:p,params:{template:{apple:"${message1}",lemon:["${message2}"]}},result:{apple:"hello",lemon:["test"]}},{inputs:{agent:"openAiAgent",row:"hello world",params:{text:"message"}},params:{template:{version:.5,nodes:{ai:{agent:"${agent}",isResult:!0,params:"${params}",inputs:{prompt:"${row}"}}}}},result:{nodes:{ai:{agent:"openAiAgent",inputs:{prompt:"hello world"},isResult:!0,params:{text:"message"}}},version:.5}}],description:"Template agent",category:["string"],author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/string_agents/string_template_agent.ts",package:"@graphai/vanilla",cacheType:"pureAgent",license:"MIT"},i=async({namedInputs:e})=>{const{text:a,data:t}=e;if(t)return{text:JSON.stringify(t,null,2)};const r=("\n"+a).match(/\n```[a-zA-z]*([\s\S]*?)\n```/);return r?{data:JSON.parse(r[1])}:{data:JSON.parse(a??"")}},l={apple:"red",lemon:"yellow"},u=JSON.stringify(l),m=["```",u,"```"].join("\n"),g=["```json",u,"```"].join("\n"),c=["```JSON",u,"```"].join("\n"),y={name:"jsonParserAgent",agent:i,mock:i,inputs:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}]},output:{type:"object",properties:{text:{type:"string",description:"json string"},data:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}]}}},samples:[{inputs:{data:l},params:{},result:{text:JSON.stringify(l,null,2)}},{inputs:{text:JSON.stringify(l,null,2)},params:{},result:{data:l}},{inputs:{text:m},params:{},result:{data:l}},{inputs:{text:g},params:{},result:{data:l}},{inputs:{text:c},params:{},result:{data:l}}],description:"Template agent",category:["string"],author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/string_agents/json_parser_agent.ts",package:"@graphai/vanilla",license:"MIT"},h=async({namedInputs:e,params:a})=>{const{suffix:t}=a,r=e.text.trim().replace(/[\s-_]+/g," ").toLowerCase().split(" ");t&&r[r.length-1]!==t&&r.push(t);const s=r.join(" ");return{lowerCamelCase:r.map(((e,a)=>0===a?e:e.charAt(0).toUpperCase()+e.slice(1))).join(""),snakeCase:s.replace(/\s+/g,"_"),kebabCase:s.replace(/\s+/g,"-"),normalized:s}},d={name:"stringCaseVariantsAgent",agent:h,mock:h,samples:[{inputs:{text:"this is a pen"},params:{},result:{kebabCase:"this-is-a-pen",lowerCamelCase:"thisIsAPen",normalized:"this is a pen",snakeCase:"this_is_a_pen"}},{inputs:{text:"string case variants"},params:{suffix:"agent"},result:{kebabCase:"string-case-variants-agent",lowerCamelCase:"stringCaseVariantsAgent",normalized:"string case variants agent",snakeCase:"string_case_variants_agent"}}],description:"Format String Cases agent",category:["string"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/string_agents/string_case_variants_agent.ts",package:"@graphai/vanilla",license:"MIT"},b=(a,t)=>async r=>{const{namedInputs:s,log:n,debugInfo:p,params:o,forNestedGraph:i}=r;e.assert(!!i,"Please update graphai to 0.5.19 or higher");const{agents:l,graphOptions:u,onLogCallback:m,callbacks:g}=i,{taskManager:c}=u,y=o.supressError??!1;if(c){const a=c.getStatus(!1);e.assert(a.concurrency>a.running,`nestedAgent: Concurrency is too low: ${a.concurrency}`)}e.assert(!!a,"nestedAgent: graph is required");const{nodes:h}=a,d=Object.keys(h).reduce(((e,a)=>{const t=h[a];if("agent"in t)e[a]=t;else{const{value:r,update:s,isResult:n,console:p}=t;e[a]={value:r,update:s,isResult:n,console:p}}return e}),{}),b={...a,nodes:d,version:e.graphDataLatestVersion},f=Object.keys(s);f.length>0&&f.forEach((e=>{void 0===b.nodes[e]?b.nodes[e]={value:s[e]}:void 0!==s[e]&&(b.nodes[e].value=s[e])}));try{void 0===b.version&&p.version&&(b.version=p.version);const a=new e.GraphAI(b,l||{},u);m&&(a.onLogCallback=m),g&&(a.callbacks=g),p.subGraphs.set(a.graphId,a);const r=await a.run(!1);return p.subGraphs.delete(a.graphId),n?.push(...a.transactionLogs()),t&&t.resultNodeId?r[t.resultNodeId]:r}catch(e){if(e instanceof Error&&y)return{onError:{message:e.message,error:e}};throw e}},f=async a=>{const{forNestedGraph:t,params:r}=a,{graphData:s}=t??{graphData:{nodes:{}}};return e.assert(!!s,"No GraphData"),await b(s,r)(a)},A={name:"nestedAgent",agent:f,mock:f,samples:[{inputs:{message:"hello"},params:{},result:{test:["hello"]},graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"messages"},inputs:{messages:[":message"]},isResult:!0}}}},{inputs:{message:"hello"},params:{resultNodeId:"test"},result:["hello"],graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"messages"},inputs:{messages:[":message"]},isResult:!0}}}}],description:"nested Agent",category:["graph"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/graph_agents/nested_agent.ts",package:"@graphai/vanilla",license:"MIT"},v={version:e.graphDataLatestVersion,nodes:{newText:{value:""},oldText:{value:""},isNewText:{if:":newText",agent:"copyAgent",inputs:{text:":newText"}},isOldText:{unless:":newText",agent:"copyAgent",inputs:{text:":oldText"}},updatedText:{agent:"copyAgent",anyInput:!0,inputs:{text:[":isNewText.text",":isOldText.text"]}},resultText:{isResult:!0,agent:"copyAgent",anyInput:!0,inputs:{text:":updatedText.text.$0"}}}},I=b(v,{resultNodeId:"resultText"}),_={name:"stringUpdateTextAgent",agent:I,mock:I,samples:[{inputs:{newText:"new",oldText:"old"},params:{},result:{text:"new"}},{inputs:{newText:"",oldText:"old"},params:{},result:{text:"old"}},{inputs:{},params:{},result:{text:""}},{inputs:{oldText:"old"},params:{},result:{text:"old"}}],description:"",category:[],author:"",repository:"",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/string_agents/string_update_text_agent.ts",package:"@graphai/vanilla",tools:[],license:"",hasGraphData:!0},T=async({namedInputs:t})=>{const r=" Set inputs: { array: :arrayNodeId, item: :itemNodeId }";a.arrayValidate("pushAgent",t,r);const{item:s,items:n}=t;e.assert(void 0!==s||void 0!==n,"pushAgent: namedInputs.item and namedInputs.items are UNDEFINED!"+r),e.assert(void 0===n||Array.isArray(n),"pushAgent: namedInputs.items is not array!");const p=t.array.map((e=>e));return void 0!==s&&p.push(s),n&&n.forEach((e=>{p.push(e)})),{array:p}},k={name:"pushAgent",agent:T,mock:T,inputs:{type:"object",properties:{array:{type:"array",description:"the array to push an item to"},item:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"},{type:"boolean"}],description:"the item push into the array"},items:{type:"array",description:"items push into the array"}},required:["array"]},output:{type:"object",properties:{array:{type:"array"}}},samples:[{inputs:{array:[1,2],item:3},params:{},result:{array:[1,2,3]}},{inputs:{array:[!0,!1],item:!1},params:{},result:{array:[!0,!1,!1]}},{inputs:{array:[{apple:1}],item:{lemon:2}},params:{},result:{array:[{apple:1},{lemon:2}]}},{inputs:{array:[{apple:1}],items:[{lemon:2},{banana:3}]},params:{},result:{array:[{apple:1},{lemon:2},{banana:3}]}}],description:"push Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/array_agents/push_agent.ts",package:"@graphai/vanilla",license:"MIT"},x=async({namedInputs:e})=>{a.arrayValidate("popAgent",e);const t=[...e.array],r=t.pop();return{array:t,item:r}},w={name:"popAgent",agent:x,mock:x,inputs:{type:"object",properties:{array:{type:"array",description:"the array to pop an item from"}},required:["array"]},output:{type:"object",properties:{item:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}],description:"the item popped from the array"},array:{type:"array",description:"the remaining array"}}},samples:[{inputs:{array:[1,2,3]},params:{},result:{array:[1,2],item:3}},{inputs:{array:["a","b","c"]},params:{},result:{array:["a","b"],item:"c"}},{inputs:{array:[1,2,3],array2:["a","b","c"]},params:{},result:{array:[1,2],item:3}}],description:"Pop Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/array_agents/pop_agent.ts",package:"@graphai/vanilla",license:"MIT"},j=async({namedInputs:e})=>{a.arrayValidate("shiftAgent",e);const t=e.array.map((e=>e)),r=t.shift();return{array:t,item:r}},E={name:"shiftAgent",agent:j,mock:j,inputs:{type:"object",properties:{array:{type:"array",description:"the array to shift an item from"}},required:["array"]},output:{type:"object",properties:{item:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}],description:"the item shifted from the array"},array:{type:"array",description:"the remaining array"}}},samples:[{inputs:{array:[1,2,3]},params:{},result:{array:[2,3],item:1}},{inputs:{array:["a","b","c"]},params:{},result:{array:["b","c"],item:"a"}}],description:"shift Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/array_agents/shift_agent.ts",package:"@graphai/vanilla",license:"MIT"},N=async({namedInputs:e,params:t})=>{a.arrayValidate("arrayFlatAgent",e);const r=t.depth??1;return{array:e.array.map((e=>e)).flat(r)}},R={name:"arrayFlatAgent",agent:N,mock:N,inputs:{type:"object",properties:{array:{type:"array",description:"The array to be flattened"}},required:["array"]},output:{type:"object",properties:{array:{type:"array",description:"flattened array"}}},params:{type:"object",properties:{depth:{type:"number",description:"flattening depth"}}},samples:[{inputs:{array:[[1],[2],[3]]},params:{},result:{array:[1,2,3]}},{inputs:{array:[[1],[2],[[3]]]},params:{},result:{array:[1,2,[3]]}},{inputs:{array:[[1],[2],[[3]]]},params:{depth:2},result:{array:[1,2,3]}},{inputs:{array:[["a"],["b"],["c"]]},params:{},result:{array:["a","b","c"]}}],description:"Array Flat Agent",category:["array"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/array_agents/array_flat_agent.ts",package:"@graphai/vanilla",cacheType:"pureAgent",license:"MIT"},M=async({namedInputs:e,params:t})=>{a.arrayValidate("arrayJoinAgent",e);const r=t.separator??"",{flat:s}=t;return{text:s?e.array.flat(s).join(r):e.array.join(r)}},O={name:"arrayJoinAgent",agent:M,mock:M,inputs:{type:"object",properties:{array:{type:"array",description:"array join"}},required:["array"]},params:{type:"object",properties:{separator:{type:"string",description:"array join separator"},flat:{type:"number",description:"array flat depth"}}},output:{type:"object",properties:{text:{type:"string",description:"joined text"}}},samples:[{inputs:{array:[[1],[2],[3]]},params:{},result:{text:"123"}},{inputs:{array:[[1],[2],[[3]]]},params:{},result:{text:"123"}},{inputs:{array:[["a"],["b"],["c"]]},params:{},result:{text:"abc"}},{inputs:{array:[[1],[2],[3]]},params:{separator:"|"},result:{text:"1|2|3"}},{inputs:{array:[[[1]],[[2],[3]]]},params:{separator:"|"},result:{text:"1|2,3"}},{inputs:{array:[[[1]],[[2],[3]]]},params:{separator:"|",flat:1},result:{text:"1|2|3"}},{inputs:{array:[[[[1]],[[2],[3]]]]},params:{separator:"|",flat:1},result:{text:"1|2,3"}},{inputs:{array:[[[[1]],[[2],[3]]]]},params:{separator:"|",flat:2},result:{text:"1|2|3"}}],description:"Array Join Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/array_agents/array_join_agent.ts",package:"@graphai/vanilla",license:"MIT"},S=async({params:t,namedInputs:r})=>{e.assert(a.isNamedInputs(r),"arrayToObjectAgent: namedInputs is UNDEFINED!");const{items:s}=r,{key:n}=t;return e.assert(void 0!==s&&Array.isArray(s),"arrayToObjectAgent: namedInputs.items is not array!"),e.assert(null!=n,"arrayToObjectAgent: params.key is UNDEFINED!"),r.items.reduce(((e,a)=>(e[a[n]]=a,e)),{})},D={name:"arrayToObjectAgent",agent:S,mock:S,inputs:{type:"object",properties:{items:{type:"array",description:"the array to pop an item from"}},required:["items"]},output:{type:"object",properties:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}],description:"the item popped from the array"}},samples:[{inputs:{items:[{id:1,data:"a"},{id:2,data:"b"}]},params:{key:"id"},result:{1:{id:1,data:"a"},2:{id:2,data:"b"}}}],description:"Array To Object Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/array_agents/array_to_object.ts",package:"@graphai/vanilla",license:"MIT"},P=async({namedInputs:a})=>{e.assert(!!a,"dotProductAgent: namedInputs is UNDEFINED!");const t=a.matrix,r=a.vector;if(t[0].length!=r.length)throw new Error(`dotProduct: Length of vectors do not match. ${t[0].length}, ${r.length}`);return t.map((e=>e.reduce(((e,a,t)=>e+a*r[t]),0)))},V={name:"dotProductAgent",agent:P,mock:P,inputs:{type:"object",properties:{matrix:{type:"array",description:"two dimentional matrix",items:{type:"array",items:{type:"number"}}},vector:{type:"array",description:"the vector",items:{type:"number"}}},required:["matrix","vector"]},output:{type:"array"},samples:[{inputs:{matrix:[[1,2],[3,4],[5,6]],vector:[3,2]},params:{},result:[7,17,27]},{inputs:{matrix:[[1,2],[2,3]],vector:[1,2]},params:{},result:[5,8]}],description:"dotProduct Agent",category:["matrix"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/matrix_agents/dot_product_agent.ts",package:"@graphai/vanilla",license:"MIT"},C=async({params:a,namedInputs:t})=>{e.assert(!!t,"sortByValue: namedInputs is UNDEFINED!"),e.assert(!!t.array,"sortByValue: namedInputs.array is UNDEFINED!"),e.assert(!!t.values,"sortByValue: namedInputs.values is UNDEFINED!");const r=a?.assendant?-1:1,s=t.array,n=t.values;return s.map(((e,a)=>({item:e,value:n[a]}))).sort(((e,a)=>(a.value-e.value)*r)).map((e=>e.item))},q={name:"sortByValuesAgent",agent:C,mock:C,inputs:{type:"object",properties:{array:{type:"array",description:"the array to sort"},values:{type:"array",description:"values associated with items in the array"}},required:["array","values"]},output:{type:"array"},samples:[{inputs:{array:["banana","orange","lemon","apple"],values:[2,5,6,4]},params:{},result:["lemon","orange","apple","banana"]},{inputs:{array:["banana","orange","lemon","apple"],values:[2,5,6,4]},params:{assendant:!0},result:["banana","apple","orange","lemon"]}],description:"sortByValues Agent",category:["matrix"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/matrix_agents/sort_by_values_agent.ts",package:"@graphai/vanilla",license:"MIT"},$=async({params:e,filterParams:a})=>e.filterParams?a:e,U={name:"echoAgent",agent:$,mock:$,samples:[{inputs:{},params:{text:"this is test"},result:{text:"this is test"}},{inputs:{},params:{text:"If you add filterParams option, it will respond to filterParams",filterParams:!0},result:{}}],description:"Echo agent",category:["test"],cacheType:"pureAgent",author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/test_agents/echo_agent.ts",package:"@graphai/vanilla",license:"MIT"},F=async({params:e})=>({list:new Array(e.count).fill(void 0).map(((e,a)=>a))}),K={name:"countingAgent",agent:F,mock:F,samples:[{inputs:{},params:{count:4},result:{list:[0,1,2,3]}}],description:"Counting agent",category:["test"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/test_agents/counting_agent.ts",package:"@graphai/vanilla",license:"MIT"},z=async({params:e})=>({messages:new Array(e.count).fill(void 0).map((()=>e.message))}),J={name:"copyMessageAgent",agent:z,mock:z,samples:[{inputs:{},params:{count:4,message:"hello"},result:{messages:["hello","hello","hello","hello"]}}],description:"CopyMessage agent",category:["test"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/test_agents/copy_message_agent.ts",package:"@graphai/vanilla",license:"MIT"},L=async({namedInputs:t,params:r})=>{e.assert(a.isNamedInputs(t),"copy2ArrayAgent: namedInputs is UNDEFINED!");const s=t.item?t.item:t;return new Array(r.count).fill(void 0).map((()=>s))},G={name:"copy2ArrayAgent",agent:L,mock:L,samples:[{inputs:{item:{message:"hello"}},params:{count:10},result:[{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"}]},{inputs:{message:"hello"},params:{count:10},result:[{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"}]},{inputs:{item:"hello"},params:{count:10},result:["hello","hello","hello","hello","hello","hello","hello","hello","hello","hello"]}],description:"Copy2Array agent",category:["test"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/test_agents/copy2array_agent.ts",package:"@graphai/vanilla",license:"MIT"},H=async({debugInfo:{nodeId:e},namedInputs:t})=>{a.arrayValidate("mergeNodeIdAgent",t);return t.array.reduce(((e,a)=>({...e,...a})),{[e]:"hello"})},X={name:"mergeNodeIdAgent",agent:H,mock:H,samples:[{inputs:{array:[{message:"hello"}]},params:{},result:{message:"hello",test:"hello"}}],description:"merge node id agent",category:["test"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/test_agents/merge_node_id_agent.ts",package:"@graphai/vanilla",license:"MIT"},Y=async({params:a,filterParams:t,namedInputs:r})=>{const s=a.message??r.message??"";for await(const r of s.split(""))t.streamTokenCallback&&t.streamTokenCallback(r),await e.sleep(a.sleep||100);return{message:s}},B={name:"streamMockAgent",agent:Y,mock:Y,inputs:{anyOf:[{type:"object",properties:{message:{type:"string",description:"streaming message"}}},{type:"array"}]},samples:[{inputs:{},params:{message:"this is params test"},result:{message:"this is params test"}},{inputs:{message:"this is named inputs test"},params:{},result:{message:"this is named inputs test"}}],description:"Stream mock agent",category:["test"],author:"Isamu Arimoto",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/test_agents/stream_mock_agent.ts",package:"@graphai/vanilla",license:"MIT",stream:!0},W=async({params:a,namedInputs:t,log:r,debugInfo:s,forNestedGraph:n})=>{e.assert(!!n,"Please update graphai to 0.5.19 or higher");const{limit:p,resultAll:o,compositeResult:i,supressError:l,rowKey:u}=a,{agents:m,graphData:g,graphOptions:c,onLogCallback:y,callbacks:h}=n,{taskManager:d}=c;if(d){const a=d.getStatus();e.assert(a.concurrency>a.running,`mapAgent: Concurrency is too low: ${a.concurrency}`)}e.assert(!!t.rows,"mapAgent: rows property is required in namedInput"),e.assert(!!g,"mapAgent: graph is required");const b=t.rows.map((e=>e));p&&p<b.length&&(b.length=p);const f=u??"row",{nodes:A}=g,v={...g,nodes:{...A},version:e.graphDataLatestVersion},I=Object.keys(t);v.nodes.__mapIndex={},I.forEach((e=>{const a="rows"===e?f:e;void 0===v.nodes[a]?v.nodes[a]={value:t[e]}:"agent"in v.nodes[a]||(v.nodes[a].value=t[e])}));try{void 0===v.version&&s.version&&(v.version=s.version);const a=b.map(((a,t)=>{const r=new e.GraphAI(v,m||{},c);return s.subGraphs.set(r.graphId,r),r.injectValue(f,a,"__mapAgent_inputs__"),r.injectValue("__mapIndex",t,"__mapAgent_inputs__"),y&&(r.onLogCallback=y),h&&(r.callbacks=h),r})),t=a.map((e=>e.run(o))),n=await Promise.all(t),p=Object.keys(n[0]);if(a.map((e=>{s.subGraphs.delete(e.graphId)})),r){const e=a.map(((e,a)=>e.transactionLogs().map((e=>(e.mapIndex=a,e)))));r.push(...e.flat())}if(i){return p.reduce(((e,a)=>(e[a]=n.map((e=>e[a])),e)),{})}return n}catch(e){if(e instanceof Error&&l)return{onError:{message:e.message,error:e}};throw e}},Q={name:"mapAgent",agent:W,mock:W,samples:[{inputs:{rows:[1,2]},params:{},result:[{test:[1]},{test:[2]}],graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]},isResult:!0}}}},{inputs:{rows:[1,2]},params:{rowKey:"myKey"},result:[{test:[1]},{test:[2]}],graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":myKey"]},isResult:!0}}}},{inputs:{rows:["apple","orange","banana","lemon","melon","pineapple","tomato"]},params:{},graph:{nodes:{node2:{agent:"stringTemplateAgent",params:{template:"I love ${word}."},inputs:{word:":row"},isResult:!0}}},result:[{node2:"I love apple."},{node2:"I love orange."},{node2:"I love banana."},{node2:"I love lemon."},{node2:"I love melon."},{node2:"I love pineapple."},{node2:"I love tomato."}]},{inputs:{rows:[{fruit:"apple"},{fruit:"orange"}]},params:{},graph:{nodes:{node2:{agent:"stringTemplateAgent",params:{template:"I love ${item}."},inputs:{item:":row.fruit"},isResult:!0}}},result:[{node2:"I love apple."},{node2:"I love orange."}]},{inputs:{rows:[{fruit:"apple"},{fruit:"orange"}],name:"You",verb:"like"},params:{},graph:{nodes:{node2:{agent:"stringTemplateAgent",params:{template:"${name} ${verb} ${fruit}."},inputs:{fruit:":row.fruit",name:":name",verb:":verb"},isResult:!0}}},result:[{node2:"You like apple."},{node2:"You like orange."}]},{inputs:{rows:[1,2]},params:{resultAll:!0},result:[{__mapIndex:0,test:[1],row:1},{__mapIndex:1,test:[2],row:2}],graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]}}}}},{inputs:{rows:[1,2]},params:{resultAll:!0},result:[{__mapIndex:0,map:[{test:1},{test:1}],row:1,test:1},{__mapIndex:1,map:[{test:2},{test:2}],test:2,row:2}],graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"row"},inputs:{row:":row"}},map:{agent:"mapAgent",inputs:{rows:[":test",":test"]},graph:{nodes:{test:{isResult:!0,agent:"copyAgent",params:{namedKey:"row"},inputs:{row:":row"}}}}}}}},{inputs:{rows:[1,2]},params:{compositeResult:!0},result:{test:[[1],[2]]},graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]},isResult:!0}}}},{inputs:{rows:["apple","orange","banana","lemon","melon","pineapple","tomato"]},params:{compositeResult:!0},graph:{nodes:{node2:{agent:"stringTemplateAgent",params:{template:"I love ${row}."},inputs:{row:":row"},isResult:!0}}},result:{node2:["I love apple.","I love orange.","I love banana.","I love lemon.","I love melon.","I love pineapple.","I love tomato."]}},{inputs:{rows:[1,2]},params:{resultAll:!0,compositeResult:!0},result:{test:[[1],[2]],__mapIndex:[0,1],row:[1,2]},graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]}}}}},{inputs:{rows:[1,2]},params:{resultAll:!0,compositeResult:!0},result:{__mapIndex:[0,1],test:[[1],[2]],map:[{test:[[[1]],[[1]]]},{test:[[[2]],[[2]]]}],row:[1,2]},graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]}},map:{agent:"mapAgent",inputs:{rows:[":test",":test"]},params:{compositeResult:!0},graph:{nodes:{test:{isResult:!0,agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]}}}}}}}}],description:"Map Agent",category:["graph"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/graph_agents/map_agent.ts",package:"@graphai/vanilla",license:"MIT"},Z=async({namedInputs:t,params:r})=>{const{flatResponse:s}=r;e.assert(a.isNamedInputs(t),"totalAgent: namedInputs is UNDEFINED! Set inputs: { array: :arrayNodeId }"),e.assert(!!t?.array,"totalAgent: namedInputs.array is UNDEFINED! Set inputs: { array: :arrayNodeId }");const n=t.array.reduce(((e,a)=>((Array.isArray(a)?a:[a]).forEach((a=>{Object.keys(a).forEach((t=>{const r=a[t];e[t]?e[t]+=r:e[t]=r}))})),e)),{});return s?n:{data:n}},ee={name:"totalAgent",agent:Z,mock:Z,inputs:{type:"object",properties:{array:{type:"array",description:"the array"}},required:["array"]},output:{type:"object"},samples:[{inputs:{array:[{a:1},{a:2},{a:3}]},params:{},result:{data:{a:6}}},{inputs:{array:[[{a:1,b:-1},{c:10}],[{a:2,b:-1}],[{a:3,b:-2},{d:-10}]]},params:{},result:{data:{a:6,b:-4,c:10,d:-10}}},{inputs:{array:[{a:1}]},params:{},result:{data:{a:1}}},{inputs:{array:[{a:1},{a:2}]},params:{},result:{data:{a:3}}},{inputs:{array:[{a:1},{a:2},{a:3}]},params:{},result:{data:{a:6}}},{inputs:{array:[{a:1,b:1},{a:2,b:2},{a:3,b:0}]},params:{},result:{data:{a:6,b:3}}},{inputs:{array:[{a:1},{a:2,b:2},{a:3,b:0}]},params:{},result:{data:{a:6,b:2}}},{inputs:{array:[{a:1},{a:2},{a:3}]},params:{flatResponse:!0},result:{a:6}},{inputs:{array:[[{a:1,b:-1},{c:10}],[{a:2,b:-1}],[{a:3,b:-2},{d:-10}]]},params:{flatResponse:!0},result:{a:6,b:-4,c:10,d:-10}},{inputs:{array:[{a:1}]},params:{flatResponse:!0},result:{a:1}},{inputs:{array:[{a:1},{a:2}]},params:{flatResponse:!0},result:{a:3}},{inputs:{array:[{a:1},{a:2},{a:3}]},params:{flatResponse:!0},result:{a:6}},{inputs:{array:[{a:1,b:1},{a:2,b:2},{a:3,b:0}]},params:{flatResponse:!0},result:{a:6,b:3}},{inputs:{array:[{a:1},{a:2,b:2},{a:3,b:0}]},params:{flatResponse:!0},result:{a:6,b:2}}],description:"Returns the sum of input values",category:["data"],author:"Satoshi Nakajima",repository:"https://github.com/snakajima/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/data_agents/total_agent.ts",package:"@graphai/vanilla",license:"MIT"},ae=async({namedInputs:t,params:r})=>{const{flatResponse:s}=r;e.assert(a.isNamedInputs(t),"dataSumTemplateAgent: namedInputs is UNDEFINED! Set inputs: { array: :arrayNodeId }"),e.assert(!!t?.array,"dataSumTemplateAgent: namedInputs.array is UNDEFINED! Set inputs: { array: :arrayNodeId }");const n=t.array.reduce(((e,a)=>e+a),0);return s?n:{result:n}},te={name:"dataSumTemplateAgent",agent:ae,mock:ae,inputs:{type:"object",properties:{array:{type:"array",description:"the array of numbers to calculate the sum of",items:{type:"integer"}}},required:["array"]},output:{type:"number"},samples:[{inputs:{array:[1]},params:{},result:{result:1}},{inputs:{array:[1,2]},params:{},result:{result:3}},{inputs:{array:[1,2,3]},params:{},result:{result:6}},{inputs:{array:[1]},params:{flatResponse:!0},result:1},{inputs:{array:[1,2]},params:{flatResponse:!0},result:3},{inputs:{array:[1,2,3]},params:{flatResponse:!0},result:6}],description:"Returns the sum of input values",category:["data"],author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/data_agents/data_sum_template_agent.ts",package:"@graphai/vanilla",license:"MIT"},re=(e,a,t,r,s,n,p,o,i)=>{const l=r||Object.keys(e),u=new Set(s??[]),m=l.reduce(((a,t)=>{if(!u.has(t)){const r=n&&n[t];r&&r[e[t]]?a[t]=r[e[t]]:a[t]=e[t]}return a}),{});return p&&p.forEach((e=>{void 0!==e.index&&e.index!==a||(m[e.propId]=t[e.from])})),i&&i.forEach((e=>{const a=t[e.from??1];e.equal?m[e.propId]=e.equal===a:e.notEqual&&(m[e.propId]=e.notEqual!==a)})),o&&Object.keys(o).forEach((e=>{const a=m[e];m[e]=m[o[e]],m[o[e]]=a})),m},se=async({namedInputs:e,params:a})=>{const{include:t,exclude:r,alter:s,inject:n,swap:p,inspect:o}=a,{array:i,item:l}=e;if(i){const[e]=i;return Array.isArray(e)?e.map(((e,a)=>re(e,a,i,t,r,s,n,p,o))):re(e,0,i,t,r,s,n,p,o)}return!!l&&re(l,0,[],t,r,s,n,p,o)},ne={array:[[{color:"red",model:"Model 3",type:"EV",maker:"Tesla",range:300},{color:"blue",model:"Model Y",type:"EV",maker:"Tesla",range:400}],"Tesla Motors"]},pe={name:"propertyFilterAgent",agent:se,mock:se,inputs:{type:"object"},output:{type:"any",properties:{array:{type:"array",description:"the array to apply filter"},item:{type:"object",description:"the object to apply filter"}}},samples:[{inputs:{array:[ne.array[0][0]]},params:{include:["color","model"]},result:{color:"red",model:"Model 3"}},{inputs:{item:ne.array[0][0]},params:{include:["color","model"]},result:{color:"red",model:"Model 3"}},{inputs:ne,params:{include:["color","model"]},result:[{color:"red",model:"Model 3"},{color:"blue",model:"Model Y"}]},{inputs:ne,params:{exclude:["color","model"]},result:[{type:"EV",maker:"Tesla",range:300},{type:"EV",maker:"Tesla",range:400}]},{inputs:{item:ne.array[0][0]},params:{exclude:["color","model"]},result:{type:"EV",maker:"Tesla",range:300}},{inputs:ne,params:{alter:{color:{red:"blue",blue:"red"}}},result:[{color:"blue",model:"Model 3",type:"EV",maker:"Tesla",range:300},{color:"red",model:"Model Y",type:"EV",maker:"Tesla",range:400}]},{inputs:{item:ne.array[0][0]},params:{alter:{color:{red:"blue",blue:"red"}}},result:{color:"blue",model:"Model 3",type:"EV",maker:"Tesla",range:300}},{inputs:ne,params:{swap:{maker:"model"}},result:[{color:"red",model:"Tesla",type:"EV",maker:"Model 3",range:300},{color:"blue",model:"Tesla",type:"EV",maker:"Model Y",range:400}]},{inputs:{item:ne.array[0][0]},params:{swap:{maker:"model"}},result:{color:"red",model:"Tesla",type:"EV",maker:"Model 3",range:300}},{inputs:ne,params:{inject:[{propId:"maker",from:1}]},result:[{color:"red",model:"Model 3",type:"EV",maker:"Tesla Motors",range:300},{color:"blue",model:"Model Y",type:"EV",maker:"Tesla Motors",range:400}]},{inputs:ne,params:{inject:[{propId:"maker",from:1,index:0}]},result:[{color:"red",model:"Model 3",type:"EV",maker:"Tesla Motors",range:300},{color:"blue",model:"Model Y",type:"EV",maker:"Tesla",range:400}]},{inputs:ne,params:{inspect:[{propId:"isTesla",equal:"Tesla Motors"},{propId:"isGM",notEqual:"Tesla Motors",from:1}]},result:[{color:"red",model:"Model 3",type:"EV",maker:"Tesla",range:300,isTesla:!0,isGM:!1},{color:"blue",model:"Model Y",type:"EV",maker:"Tesla",range:400,isTesla:!0,isGM:!1}]}],description:"Filter properties based on property name either with 'include', 'exclude', 'alter', 'swap', 'inject', 'inspect'",category:["data"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/data_agents/property_filter_agent.ts",package:"@graphai/vanilla",license:"MIT"},oe=async({namedInputs:t,params:r})=>{const{namedKey:s}=r;return e.assert(a.isNamedInputs(t),"copyAgent: namedInputs is UNDEFINED!"),s?t[s]:t},ie={name:"copyAgent",agent:oe,mock:oe,inputs:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}]},output:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}]},samples:[{inputs:{color:"red",model:"Model 3"},params:{},result:{color:"red",model:"Model 3"}},{inputs:{array:["Hello World","Discarded"]},params:{},result:{array:["Hello World","Discarded"]}},{inputs:{color:"red",model:"Model 3"},params:{namedKey:"color"},result:"red"}],description:"Returns namedInputs",category:["data"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/data_agents/copy_agent.ts",package:"@graphai/vanilla",license:"MIT"},le=async({namedInputs:t,params:r})=>{const{namedKey:s}=t;e.assert(a.isNamedInputs(t),"lookupDictionaryAgent: namedInputs is UNDEFINED!");const n=r[s];if(!r.supressError&&void 0===n)throw new Error(`lookupDictionaryAgent error: ${s} is missing`);return n},ue={openai:{model:"gpt4-o",temperature:.7},groq:{model:"llama3-8b-8192",temperature:.6},gemini:{model:"gemini-2.0-pro-exp-02-05",temperature:.7}},me={name:"lookupDictionaryAgent",agent:le,mock:le,inputs:{type:"object",properties:{namedKey:{type:"string",description:"key of params"}},required:["namedKey"]},output:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}]},samples:[{inputs:{namedKey:"openai"},params:ue,result:{model:"gpt4-o",temperature:.7}},{inputs:{namedKey:"gemini"},params:ue,result:{model:"gemini-2.0-pro-exp-02-05",temperature:.7}}],description:"Select elements with params",category:["data"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/data_agents/lookup_dictionary_agent.ts",package:"@graphai/vanilla",license:"MIT"},ge=async({namedInputs:t})=>{e.assert(a.isNamedInputs(t),"mergeObjectAgent: namedInputs is UNDEFINED!");const{items:r}=t;return e.assert(void 0!==r&&Array.isArray(r),"mergeObjectAgent: namedInputs.items is not array!"),Object.assign({},...r)},ce={name:"mergeObjectAgent",agent:ge,mock:ge,inputs:{anyOf:[{type:"object"}]},output:{anyOf:{type:"object"}},samples:[{inputs:{items:[{color:"red"},{model:"Model 3"}]},params:{},result:{color:"red",model:"Model 3"}}],description:"Returns namedInputs",category:["data"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/data_agents/merge_objects_agent.ts",package:"@graphai/vanilla",license:"MIT"},ye=["GET","HEAD","POST","OPTIONS","PUT","DELETE","PATCH"],he=["POST","PUT","PATCH"],de=async({namedInputs:a,params:t,config:r})=>{const{url:s,method:n,queryParams:p,body:o}={...t,...a};e.assert(!!s,"fetchAgent: no url");const i=t.supressError??!1,l=new URL(s),u={...t.headers?t.headers:{},...a.headers?a.headers:{}};if(r&&r.authorization&&(u.Authorization=r.authorization),p){const e=new URLSearchParams(p);l.search=e.toString()}o&&(u["Content-Type"]="application/json");const m={method:n?n.toUpperCase():o?"POST":"GET",headers:new Headers(u),body:o?JSON.stringify(o):void 0};if(e.assert(ye.includes(m.method??""),"fetchAgent: invalid method: "+m.method),e.assert(!he.includes(m.method??"")||!!o,"fetchAgent: The request body is required for this method: "+m.method),t?.debug)return{url:l.toString(),method:m.method,headers:u,body:m.body};const g=await fetch(l.toString(),m);if(!g.ok){const e=g.status,a="json"===(t?.type??"json")?await g.json():await g.text();if(i)return{onError:{message:`HTTP error: ${e}`,status:e,error:a}};throw new Error(`HTTP error: ${e}`)}const c=await(async()=>{const e=t?.type??"json";if("json"===e)return await g.json();if("text"===e)return g.text();throw new Error(`Unknown Type! ${e}`)})();return!1===t.flatResponse?{data:c}:c},be={name:"vanillaFetchAgent",agent:de,mock:de,inputs:{type:"object",properties:{url:{type:"string",description:"baseurl"},method:{type:"string",description:"HTTP method"},headers:{type:"object",description:"HTTP headers"},quaryParams:{type:"object",description:"Query parameters"},body:{anyOf:[{type:"string"},{type:"object"}],description:"body"}},required:[]},output:{type:"array"},samples:[{inputs:{url:"https://example.com",queryParams:{foo:"bar"},headers:{"x-myHeader":"secret"}},params:{debug:!0},result:{method:"GET",url:"https://example.com/?foo=bar",headers:{"x-myHeader":"secret"},body:void 0}},{inputs:{url:"https://example.com",body:{foo:"bar"}},params:{debug:!0},result:{method:"POST",url:"https://example.com/",headers:{"Content-Type":"application/json"},body:JSON.stringify({foo:"bar"})}},{inputs:{url:"https://example.com",body:{foo:"bar"},method:"PUT"},params:{debug:!0},result:{method:"PUT",url:"https://example.com/",headers:{"Content-Type":"application/json"},body:JSON.stringify({foo:"bar"})}},{inputs:{url:"https://example.com",method:"options"},params:{debug:!0},result:{method:"OPTIONS",url:"https://example.com/",headers:{},body:void 0}},{inputs:{},params:{url:"https://example.com",body:{foo:"bar"},method:"PUT",debug:!0},result:{method:"PUT",url:"https://example.com/",headers:{"Content-Type":"application/json"},body:JSON.stringify({foo:"bar"})}},{inputs:{method:"DELETE",headers:{authentication:"bearer XXX"}},params:{url:"https://example.com",body:{foo:"bar"},method:"PUT",headers:{"Content-Type":"application/json"},debug:!0},result:{method:"DELETE",url:"https://example.com/",headers:{"Content-Type":"application/json",authentication:"bearer XXX"},body:JSON.stringify({foo:"bar"})}}],description:"Retrieves JSON data from the specified URL",category:["service"],author:"Receptron",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/service_agents/vanilla_fetch_agent.ts",package:"@graphai/vanilla",license:"MIT"},fe=async({params:a,namedInputs:t})=>(await e.sleep(a?.duration??10),t),Ae={name:"sleeperAgent",agent:fe,mock:fe,samples:[{inputs:{},params:{duration:1},result:{}},{inputs:{array:[{a:1},{b:2}]},params:{duration:1},result:{array:[{a:1},{b:2}]}}],description:"sleeper Agent",category:["sleeper"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/sleeper_agents/sleeper_agent.ts",package:"@graphai/vanilla",license:"MIT"},ve=e=>{const a=e.map((e=>Array.isArray(e)?ve(e):e)),[t,r,s]=a;if("=="===r)return t===s;if("!="===r)return t!==s;if(">"===r)return Number(t)>Number(s);if(">="===r)return Number(t)>=Number(s);if("<"===r)return Number(t)<Number(s);if("<="===r)return Number(t)<=Number(s);if("||"===r)return!!t||!!s;if("&&"===r)return!!t&&!!s;if("XOR"===r)return!!t==!s;throw new Error("unknown compare operator")},Ie=e=>null==e,_e=async({namedInputs:e,params:a})=>{const{array:t,leftValue:r,rightValue:s}=e,n=t??[],p=(()=>{if(2===n.length&&a.operator)return[n[0],a.operator,n[1]];if(3===n.length)return n;if(0===n.length&&!Ie(r)&&!Ie(s)&&a.operator)return[r,a.operator,s];throw new Error("compare inputs is wrong.")})(),o=ve(p);return a?.value?{result:a?.value[o?"true":"false"]??o}:{result:o}},Te={name:"compareAgent",agent:_e,mock:_e,inputs:{},output:{},samples:[{inputs:{array:["abc","==","abc"]},params:{value:{true:"a",false:"b"}},result:{result:"a"}},{inputs:{array:["abc","==","abca"]},params:{value:{true:"a",false:"b"}},result:{result:"b"}},{inputs:{array:["abc","==","abc"]},params:{},result:{result:!0}},{inputs:{array:["abc","==","abcd"]},params:{},result:{result:!1}},{inputs:{array:["abc","!=","abc"]},params:{},result:{result:!1}},{inputs:{array:["abc","!=","abcd"]},params:{},result:{result:!0}},{inputs:{array:["10",">","5"]},params:{},result:{result:!0}},{inputs:{array:["10",">","15"]},params:{},result:{result:!1}},{inputs:{array:[10,">",5]},params:{},result:{result:!0}},{inputs:{array:[10,">",15]},params:{},result:{result:!1}},{inputs:{array:["10",">=","5"]},params:{},result:{result:!0}},{inputs:{array:["10",">=","10"]},params:{},result:{result:!0}},{inputs:{array:["10",">=","19"]},params:{},result:{result:!1}},{inputs:{array:[10,">=",5]},params:{},result:{result:!0}},{inputs:{array:[10,">=",10]},params:{},result:{result:!0}},{inputs:{array:[10,">=",19]},params:{},result:{result:!1}},{inputs:{array:["10","<","5"]},params:{},result:{result:!1}},{inputs:{array:["10","<","15"]},params:{},result:{result:!0}},{inputs:{array:[10,"<",5]},params:{},result:{result:!1}},{inputs:{array:[10,"<",15]},params:{},result:{result:!0}},{inputs:{array:["10","<=","5"]},params:{},result:{result:!1}},{inputs:{array:["10","<=","10"]},params:{},result:{result:!0}},{inputs:{array:["10","<=","19"]},params:{},result:{result:!0}},{inputs:{array:[10,"<=",5]},params:{},result:{result:!1}},{inputs:{array:[10,"<=",10]},params:{},result:{result:!0}},{inputs:{array:[10,"<=",19]},params:{},result:{result:!0}},{inputs:{array:[!0,"||",!1]},params:{},result:{result:!0}},{inputs:{array:[!1,"||",!1]},params:{},result:{result:!1}},{inputs:{array:[!0,"&&",!1]},params:{},result:{result:!1}},{inputs:{array:[!0,"&&",!0]},params:{},result:{result:!0}},{inputs:{array:[!0,"XOR",!1]},params:{},result:{result:!0}},{inputs:{array:[!1,"XOR",!0]},params:{},result:{result:!0}},{inputs:{array:[!1,"XOR",!1]},params:{},result:{result:!1}},{inputs:{array:[!0,"XOR",!0]},params:{},result:{result:!1}},{inputs:{array:[["aaa","==","aaa"],"||",["aaa","==","bbb"]]},params:{},result:{result:!0}},{inputs:{array:[["aaa","==","aaa"],"&&",["aaa","==","bbb"]]},params:{},result:{result:!1}},{inputs:{array:[[["aaa","==","aaa"],"&&",["bbb","==","bbb"]],"||",["aaa","&&","bbb"]]},params:{},result:{result:!0}},{inputs:{array:["abc","abc"]},params:{value:{true:"a",false:"b"},operator:"=="},result:{result:"a"}},{inputs:{array:["abc","abca"]},params:{value:{true:"a",false:"b"},operator:"=="},result:{result:"b"}},{inputs:{array:["abc","abc"]},params:{operator:"=="},result:{result:!0}},{inputs:{array:["abc","abcd"]},params:{operator:"=="},result:{result:!1}},{inputs:{array:["abc","abc"]},params:{operator:"!="},result:{result:!1}},{inputs:{array:["abc","abcd"]},params:{operator:"!="},result:{result:!0}},{inputs:{array:["10","5"]},params:{operator:">"},result:{result:!0}},{inputs:{array:["10","15"]},params:{operator:">"},result:{result:!1}},{inputs:{array:[10,5]},params:{operator:">"},result:{result:!0}},{inputs:{array:[10,15]},params:{operator:">"},result:{result:!1}},{inputs:{array:["10","5"]},params:{operator:">="},result:{result:!0}},{inputs:{array:["10","10"]},params:{operator:">="},result:{result:!0}},{inputs:{array:["10","19"]},params:{operator:">="},result:{result:!1}},{inputs:{array:[10,5]},params:{operator:">="},result:{result:!0}},{inputs:{array:[10,10]},params:{operator:">="},result:{result:!0}},{inputs:{array:[10,19]},params:{operator:">="},result:{result:!1}},{inputs:{array:["10","5"]},params:{operator:"<"},result:{result:!1}},{inputs:{array:["10","15"]},params:{operator:"<"},result:{result:!0}},{inputs:{array:[10,5]},params:{operator:"<"},result:{result:!1}},{inputs:{array:[10,15]},params:{operator:"<"},result:{result:!0}},{inputs:{array:[!0,!1]},params:{operator:"||"},result:{result:!0}},{inputs:{array:[!1,!1]},params:{operator:"||"},result:{result:!1}},{inputs:{array:[!0,!1]},params:{operator:"&&"},result:{result:!1}},{inputs:{array:[!0,!0]},params:{operator:"&&"},result:{result:!0}},{inputs:{array:[!0,!1]},params:{operator:"XOR"},result:{result:!0}},{inputs:{array:[!1,!0]},params:{operator:"XOR"},result:{result:!0}},{inputs:{array:[!1,!1]},params:{operator:"XOR"},result:{result:!1}},{inputs:{array:[!0,!0]},params:{operator:"XOR"},result:{result:!1}},{inputs:{leftValue:"abc",rightValue:"abc"},params:{value:{true:"a",false:"b"},operator:"=="},result:{result:"a"}},{inputs:{leftValue:"abc",rightValue:"abca"},params:{value:{true:"a",false:"b"},operator:"=="},result:{result:"b"}}],description:"compare",category:["compare"],author:"Receptron",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/compare_agents/compare_agent.ts",package:"@graphai/vanilla",license:"MIT"},ke=async({namedInputs:t,params:r})=>{const{imageType:s,detail:n}=r,{array:p,prompt:o}=t;a.arrayValidate("images2messageAgent",t),e.assert(!!s,"images2messageAgent: params.imageType is UNDEFINED! Set Type: png, jpg...");const i=p.map((e=>{const a=((e,a,t)=>"http"===a?{url:e}:{url:`data:image/${a};base64,${e}`,detail:t??"auto"})(e,s,n);return{type:"image_url",image_url:a}}));return o&&i.unshift({type:"text",text:o}),{message:{role:"user",content:i}}},xe={name:"images2messageAgent",agent:ke,mock:ke,inputs:{type:"object",properties:{array:{type:"array",description:"the array of base64 image data"},prompt:{type:"string",description:"prompt message"}},required:["array"]},output:{type:"object"},samples:[{inputs:{array:["abcabc","122123"]},params:{imageType:"png"},result:{message:{content:[{image_url:{detail:"auto",url:"data:image/png;base64,abcabc"},type:"image_url"},{image_url:{detail:"auto",url:"data:image/png;base64,122123"},type:"image_url"}],role:"user"}}},{inputs:{array:["abcabc","122123"],prompt:"hello"},params:{imageType:"jpg",detail:"high"},result:{message:{content:[{type:"text",text:"hello"},{image_url:{detail:"high",url:"data:image/jpg;base64,abcabc"},type:"image_url"},{image_url:{detail:"high",url:"data:image/jpg;base64,122123"},type:"image_url"}],role:"user"}}},{inputs:{array:["http://example.com/1.jpg","http://example.com/2.jpg"]},params:{imageType:"http"},result:{message:{content:[{image_url:{url:"http://example.com/1.jpg"},type:"image_url"},{image_url:{url:"http://example.com/2.jpg"},type:"image_url"}],role:"user"}}}],description:"Returns the message data for llm include image",category:["image"],author:"Receptron team",repository:"https://github.com/snakajima/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/images_agents/image_to_message_agent.ts",package:"@graphai/vanilla",license:"MIT"},we=async({params:e,namedInputs:a,config:t})=>{const{array:r,item:s}=a,{apiKey:n,model:p,baseURL:o}={...t||{},...e},i=o??"https://api.openai.com/v1/embeddings",l=p??"text-embedding-3-small",u=n??process.env.OPENAI_API_KEY,m={"Content-Type":"application/json",Authorization:u?`Bearer ${u}`:""},g=r??[s],c=await fetch(i,{method:"POST",headers:m,body:JSON.stringify({input:g,model:l})}),y=await c.json();if(!c.ok)throw new Error(`HTTP error! status: ${c.status}`);return"data"in y?y.data.map((e=>e.embedding)):"embeddings"in y?y.embeddings:void 0},je={name:"stringEmbeddingsAgent",agent:we,mock:we,samples:[],description:"Embeddings Agent",category:["embedding"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/embedding_agent.ts",package:"@graphai/vanilla",cacheType:"pureAgent",license:"MIT"};exports.arrayFlatAgent=R,exports.arrayJoinAgent=O,exports.arrayToObjectAgent=D,exports.compareAgent=Te,exports.copy2ArrayAgent=G,exports.copyAgent=ie,exports.copyMessageAgent=J,exports.countingAgent=K,exports.dataSumTemplateAgent=te,exports.dotProductAgent=V,exports.echoAgent=U,exports.images2messageAgent=xe,exports.jsonParserAgent=y,exports.lookupDictionaryAgent=me,exports.mapAgent=Q,exports.mergeNodeIdAgent=X,exports.mergeObjectAgent=ce,exports.nestedAgent=A,exports.popAgent=w,exports.propertyFilterAgent=pe,exports.pushAgent=k,exports.shiftAgent=E,exports.sleeperAgent=Ae,exports.sortByValuesAgent=q,exports.streamMockAgent=B,exports.stringCaseVariantsAgent=d,exports.stringEmbeddingsAgent=je,exports.stringSplitterAgent=r,exports.stringTemplateAgent=o,exports.stringUpdateTextAgent=_,exports.totalAgent=ee,exports.vanillaFetchAgent=be;
//# sourceMappingURL=bundle.cjs.min.js.map
